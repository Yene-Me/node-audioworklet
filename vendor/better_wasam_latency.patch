diff --git a/example/sio_sine.c b/example/sio_sine.c
index cc70c67..4364784 100644
--- a/example/sio_sine.c
+++ b/example/sio_sine.c
@@ -195,6 +195,27 @@ int main(int argc, char **argv) {
         return 1;
     }
 
+    if (raw && !device_id) {
+        struct SoundIoDevice *device_shared = soundio_get_output_device(soundio, selected_device_index);
+        selected_device_index = -1;
+        int device_count = soundio_output_device_count(soundio);
+        for (int i = 0; i < device_count; i += 1) {
+            struct SoundIoDevice *device = soundio_get_output_device(soundio, i);
+            bool select_this_one = strcmp(device->id, device_shared->id) == 0 && device->is_raw == raw;
+            soundio_device_unref(device);
+            if (select_this_one) {
+                selected_device_index = i;
+                break;
+            }
+        }
+        soundio_device_unref(device_shared);
+
+        if (selected_device_index < 0) {
+            fprintf(stderr, "Raw output device not found\n");
+            return 1;
+        }
+    }
+
     struct SoundIoDevice *device = soundio_get_output_device(soundio, selected_device_index);
     if (!device) {
         fprintf(stderr, "out of memory\n");
diff --git a/src/wasapi.c b/src/wasapi.c
index 027c498..e5d3301 100644
--- a/src/wasapi.c
+++ b/src/wasapi.c
@@ -37,6 +37,8 @@
 
 // And some constants are passed by reference
 #define IID_IAUDIOCLIENT                      (IID_IAudioClient)
+#define IID_IAUDIOCLIENT2                     (IID_IAudioClient2)
+#define IID_IAUDIOCLIENT3                     (IID_IAudioClient3)
 #define IID_IMMENDPOINT                       (IID_IMMEndpoint)
 #define IID_IAUDIOCLOCKADJUSTMENT             (IID_IAudioClockAdjustment)
 #define IID_IAUDIOSESSIONCONTROL              (IID_IAudioSessionControl)
@@ -62,6 +64,14 @@ static const IID   IID_IAudioClient = {
     //MIDL_INTERFACE("1CB9AD4C-DBFA-4c32-B178-C2F568A703B2")
     0x1cb9ad4c, 0xdbfa, 0x4c32, {0xb1, 0x78, 0xc2, 0xf5, 0x68, 0xa7, 0x03, 0xb2}
 };
+static const IID   IID_IAudioClient2 = {
+    //MIDL_INTERFACE("726778CD-F60A-4eda-82DE-E47610CD78AA")
+    0x726778cd, 0xf60a, 0x4eda, {0x82, 0xde, 0xe4, 0x76, 0x10, 0xcd, 0x78, 0xaa}
+};
+static const IID   IID_IAudioClient3 = {
+    //MIDL_INTERFACE("7ED4EE07-8E67-4CD4-8C1A-2B7A5987AD42")
+    0x7ed4ee07, 0x8e67, 0x4cd4, {0x8c, 0x1a, 0x2b, 0x7a, 0x59, 0x87, 0xad, 0x42}
+};
 static const IID   IID_IAudioRenderClient    = {
     //MIDL_INTERFACE("F294ACFC-3146-4483-A7BF-ADDCA7C260E2")
     0xf294acfc, 0x3146, 0x4483, {0xa7, 0xbf, 0xad, 0xdc, 0xa7, 0xc2, 0x60, 0xe2}
@@ -96,6 +106,8 @@ static const IID IID_ISimpleAudioVolume = {
 #define IS_EQUAL_IID(a, b) IsEqualIID((a), (b))
 
 #define IID_IAUDIOCLIENT (&IID_IAudioClient)
+#define IID_IAUDIOCLIENT2 (&IID_IAudioClient2)
+#define IID_IAUDIOCLIENT3 (&IID_IAudioClient3)
 #define IID_IMMENDPOINT (&IID_IMMEndpoint)
 #define PKEY_DEVICE_FRIENDLYNAME (&PKEY_Device_FriendlyName)
 #define PKEY_AUDIOENGINE_DEVICEFORMAT (&PKEY_AudioEngine_DeviceFormat)
@@ -467,6 +479,7 @@ struct RefreshDevices {
     IMMEndpoint *endpoint;
     IPropertyStore *prop_store;
     IAudioClient *audio_client;
+    IAudioClient3 *audio_client3;
     LPWSTR lpwstr;
     PROPVARIANT prop_variant_value;
     WAVEFORMATEXTENSIBLE *wave_format;
@@ -504,6 +517,8 @@ static void deinit_refresh_devices(struct RefreshDevices *rd) {
         CoTaskMemFree(rd->wave_format);
     if (rd->audio_client)
         IUnknown_Release(rd->audio_client);
+    if (rd->audio_client3)
+        IUnknown_Release(rd->audio_client3);
 }
 
 static int detect_valid_layouts(struct RefreshDevices *rd, WAVEFORMATEXTENSIBLE *wave_format,
@@ -878,9 +893,23 @@ static int refresh_devices(struct SoundIoPrivate *si) {
             IUnknown_Release(rd.audio_client);
             rd.audio_client = NULL;
         }
-        if (FAILED(hr = IMMDevice_Activate(rd.mm_device, IID_IAUDIOCLIENT,
-                        CLSCTX_ALL, NULL, (void**)&rd.audio_client)))
+        if (rd.audio_client3) {
+            IUnknown_Release(rd.audio_client3);
+            rd.audio_client3 = NULL;
+        }
+
+        if (SUCCEEDED(hr = IMMDevice_Activate(rd.mm_device, IID_IAUDIOCLIENT3,
+            CLSCTX_ALL, NULL, (void**)&rd.audio_client3)))
         {
+            hr = IMMDevice_QueryInterface(rd.audio_client3, IID_IAUDIOCLIENT,
+                (void**)&rd.audio_client);
+        }
+        else {
+            hr = IMMDevice_Activate(rd.mm_device, IID_IAUDIOCLIENT,
+                CLSCTX_ALL, NULL, (void**)&rd.audio_client);
+        }
+
+        if (FAILED(hr)) {
             rd.device_shared->probe_error = SoundIoErrorOpeningDevice;
             rd.device_raw->probe_error = SoundIoErrorOpeningDevice;
             rd.device_shared = NULL;
@@ -900,10 +929,11 @@ static int refresh_devices(struct SoundIoPrivate *si) {
             continue;
         }
         dev_w_shared->period_duration = from_reference_time(default_device_period);
-        rd.device_shared->software_latency_current = dev_w_shared->period_duration;
+        rd.device_shared->software_latency_min = dev_w_shared->period_duration * 2;
 
         dev_w_raw->period_duration = from_reference_time(min_device_period);
-        rd.device_raw->software_latency_min = dev_w_raw->period_duration * 2;
+        rd.device_raw->software_latency_current = dev_w_raw->period_duration * 2;
+        rd.device_raw->software_latency_min = dev_w_raw->period_duration;
 
         if (rd.prop_store) {
             IPropertyStore_Release(rd.prop_store);
@@ -1017,6 +1047,26 @@ static int refresh_devices(struct SoundIoPrivate *si) {
             rd.device_shared->sample_rate_current = rd.wave_format->Format.nSamplesPerSec;
             rd.device_shared->current_format = from_wave_format_format(rd.wave_format);
 
+            if (rd.audio_client3) {
+                UINT32 default_period;
+                UINT32 fundamental_period;
+                UINT32 min_period;
+                UINT32 max_period;
+
+                AudioClientProperties properties = { 0 };
+                properties.cbSize = sizeof(AudioClientProperties);
+                properties.Options = AUDCLNT_STREAMOPTIONS_NONE;
+
+                if (SUCCEEDED(hr = IAudioClient2_SetClientProperties(rd.audio_client3, &properties))) {
+                    if (SUCCEEDED(hr = IAudioClient3_GetSharedModeEnginePeriod(rd.audio_client3,
+                        &rd.wave_format->Format, &default_period, &fundamental_period, &min_period, &max_period)))
+                    {
+                        rd.device_shared->software_latency_min =
+                            2 * (double)min_period / rd.device_shared->sample_rate_current;
+                    }
+                }
+            }
+
             if (rd.device_shared->aim == SoundIoDeviceAimOutput) {
                 // For output streams in shared mode,
                 // WASAPI performs resampling, so any value is valid.
@@ -1241,19 +1291,35 @@ static int outstream_do_open(struct SoundIoPrivate *si, struct SoundIoOutStreamP
     struct SoundIoDevice *device = outstream->device;
     struct SoundIoDevicePrivate *dev = (struct SoundIoDevicePrivate *)device;
     struct SoundIoDeviceWasapi *dw = &dev->backend_data.wasapi;
+    IAudioClient3* audio_client3;
     HRESULT hr;
 
-    if (FAILED(hr = IMMDevice_Activate(dw->mm_device, IID_IAUDIOCLIENT,
+    if (!osw->is_raw && SUCCEEDED(hr = IMMDevice_Activate(dw->mm_device, IID_IAUDIOCLIENT3,
+                    CLSCTX_ALL, NULL, (void**)&audio_client3)))
+    {
+        if (FAILED(hr = IMMDevice_QueryInterface(audio_client3, IID_IAUDIOCLIENT, (void**)&osw->audio_client)))
+        {
+            IUnknown_Release(audio_client3);
+            return SoundIoErrorOpeningDevice;
+        }
+    }
+    else if (FAILED(hr = IMMDevice_Activate(dw->mm_device, IID_IAUDIOCLIENT,
                     CLSCTX_ALL, NULL, (void**)&osw->audio_client)))
     {
         return SoundIoErrorOpeningDevice;
     }
 
+    if (outstream->software_latency == 0.0)
+        outstream->software_latency = 1.0;
+
+    outstream->software_latency = soundio_double_clamp(device->software_latency_min,
+        outstream->software_latency, device->software_latency_max);
 
     AUDCLNT_SHAREMODE share_mode;
     DWORD flags;
     REFERENCE_TIME buffer_duration;
     REFERENCE_TIME periodicity;
+    UINT32 periodicity_in_frames;
     WAVEFORMATEXTENSIBLE wave_format = {0};
     wave_format.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
     wave_format.Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
@@ -1261,7 +1327,7 @@ static int outstream_do_open(struct SoundIoPrivate *si, struct SoundIoOutStreamP
         wave_format.Format.nSamplesPerSec = outstream->sample_rate;
         flags = AUDCLNT_STREAMFLAGS_EVENTCALLBACK;
         share_mode = AUDCLNT_SHAREMODE_EXCLUSIVE;
-        periodicity = to_reference_time(dw->period_duration);
+        periodicity = to_reference_time(outstream->software_latency);
         buffer_duration = periodicity;
     } else {
         WAVEFORMATEXTENSIBLE *mix_format;
@@ -1270,66 +1336,112 @@ static int outstream_do_open(struct SoundIoPrivate *si, struct SoundIoOutStreamP
         }
         wave_format.Format.nSamplesPerSec = (DWORD)outstream->sample_rate;
         osw->need_resample = (mix_format->Format.nSamplesPerSec != wave_format.Format.nSamplesPerSec);
-        CoTaskMemFree(mix_format);
-        mix_format = NULL;
         flags = osw->need_resample ? AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM | AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY : 0;
         share_mode = AUDCLNT_SHAREMODE_SHARED;
         periodicity = 0;
-        buffer_duration = to_reference_time(4.0);
+        buffer_duration = to_reference_time(outstream->software_latency);
+
+        if (osw->need_resample && audio_client3 != NULL) {
+            // we can't use resampling with this new interface, fallback to old method
+            IUnknown_Release(audio_client3);
+            audio_client3 = NULL;
+        }
+        if (audio_client3 != NULL) {
+            UINT32 default_period;
+            UINT32 fundamental_period;
+            UINT32 min_period;
+            UINT32 max_period;
+
+            AudioClientProperties properties = { 0 };
+            properties.cbSize = sizeof(AudioClientProperties);
+            properties.Options = AUDCLNT_STREAMOPTIONS_NONE;
+
+            if (SUCCEEDED(hr = IAudioClient2_SetClientProperties(audio_client3, &properties)) &&
+                SUCCEEDED(hr = IAudioClient3_GetSharedModeEnginePeriod(audio_client3, &mix_format->Format,
+                    &default_period, &fundamental_period, &min_period, &max_period)))
+            {
+                periodicity_in_frames = fundamental_period * (UINT32)(mix_format->Format.nSamplesPerSec *
+                    outstream->software_latency / 2 / fundamental_period);
+
+                if (periodicity_in_frames > max_period) {
+                    IUnknown_Release(audio_client3);
+                    audio_client3 = NULL;
+                }
+            } else {
+                IUnknown_Release(audio_client3);
+                audio_client3 = NULL;
+            }
+        }
+        CoTaskMemFree(mix_format);
+        mix_format = NULL;
     }
     to_wave_format_layout(&outstream->layout, &wave_format);
     to_wave_format_format(outstream->format, &wave_format);
     complete_wave_format_data(&wave_format);
 
-    if (FAILED(hr = IAudioClient_Initialize(osw->audio_client, share_mode, flags,
-            buffer_duration, periodicity, (WAVEFORMATEX*)&wave_format, NULL)))
+    if (audio_client3 != NULL) {
+        if (FAILED(hr = IAudioClient3_InitializeSharedAudioStream(audio_client3,
+            flags, periodicity_in_frames, (WAVEFORMATEX*)&wave_format, NULL)))
+        {
+            IUnknown_Release(audio_client3);
+            return SoundIoErrorOpeningDevice;
+        }
+
+        IUnknown_Release(audio_client3);
+        audio_client3 = NULL;
+    }
+    else
     {
-        if (hr == AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED) {
-            if (FAILED(hr = IAudioClient_GetBufferSize(osw->audio_client, &osw->buffer_frame_count))) {
-                return SoundIoErrorOpeningDevice;
-            }
-            IUnknown_Release(osw->audio_client);
-            osw->audio_client = NULL;
-            if (FAILED(hr = IMMDevice_Activate(dw->mm_device, IID_IAUDIOCLIENT,
-                            CLSCTX_ALL, NULL, (void**)&osw->audio_client)))
-            {
-                return SoundIoErrorOpeningDevice;
-            }
-            if (!osw->is_raw) {
-                WAVEFORMATEXTENSIBLE *mix_format;
-                if (FAILED(hr = IAudioClient_GetMixFormat(osw->audio_client, (WAVEFORMATEX **)&mix_format))) {
+        if (FAILED(hr = IAudioClient_Initialize(osw->audio_client, share_mode, flags,
+                buffer_duration, periodicity, (WAVEFORMATEX*)&wave_format, NULL)))
+        {
+            if (hr == AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED) {
+                if (FAILED(hr = IAudioClient_GetBufferSize(osw->audio_client, &osw->buffer_frame_count))) {
                     return SoundIoErrorOpeningDevice;
                 }
-                wave_format.Format.nSamplesPerSec = (DWORD)outstream->sample_rate;
-                osw->need_resample = (mix_format->Format.nSamplesPerSec != wave_format.Format.nSamplesPerSec);
-                CoTaskMemFree(mix_format);
-                mix_format = NULL;
-                flags = osw->need_resample ? AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM | AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY : 0;
-                to_wave_format_layout(&outstream->layout, &wave_format);
-                to_wave_format_format(outstream->format, &wave_format);
-                complete_wave_format_data(&wave_format);
-            }
-
-            buffer_duration = to_reference_time(osw->buffer_frame_count / (double)outstream->sample_rate);
-            if (osw->is_raw)
-                periodicity = buffer_duration;
-            if (FAILED(hr = IAudioClient_Initialize(osw->audio_client, share_mode, flags,
-                    buffer_duration, periodicity, (WAVEFORMATEX*)&wave_format, NULL)))
-            {
-                if (hr == AUDCLNT_E_UNSUPPORTED_FORMAT) {
-                    return SoundIoErrorIncompatibleDevice;
-                } else if (hr == E_OUTOFMEMORY) {
-                    return SoundIoErrorNoMem;
-                } else {
+                IUnknown_Release(osw->audio_client);
+                osw->audio_client = NULL;
+                if (FAILED(hr = IMMDevice_Activate(dw->mm_device, IID_IAUDIOCLIENT,
+                                CLSCTX_ALL, NULL, (void**)&osw->audio_client)))
+                {
                     return SoundIoErrorOpeningDevice;
                 }
+                if (!osw->is_raw) {
+                    WAVEFORMATEXTENSIBLE *mix_format;
+                    if (FAILED(hr = IAudioClient_GetMixFormat(osw->audio_client, (WAVEFORMATEX **)&mix_format))) {
+                        return SoundIoErrorOpeningDevice;
+                    }
+                    wave_format.Format.nSamplesPerSec = (DWORD)outstream->sample_rate;
+                    osw->need_resample = (mix_format->Format.nSamplesPerSec != wave_format.Format.nSamplesPerSec);
+                    CoTaskMemFree(mix_format);
+                    mix_format = NULL;
+                    flags = osw->need_resample ? AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM | AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY : 0;
+                    to_wave_format_layout(&outstream->layout, &wave_format);
+                    to_wave_format_format(outstream->format, &wave_format);
+                    complete_wave_format_data(&wave_format);
+                }
+
+                buffer_duration = to_reference_time(osw->buffer_frame_count / (double)outstream->sample_rate);
+                if (osw->is_raw)
+                    periodicity = buffer_duration;
+                if (FAILED(hr = IAudioClient_Initialize(osw->audio_client, share_mode, flags,
+                        buffer_duration, periodicity, (WAVEFORMATEX*)&wave_format, NULL)))
+                {
+                    if (hr == AUDCLNT_E_UNSUPPORTED_FORMAT) {
+                        return SoundIoErrorIncompatibleDevice;
+                    } else if (hr == E_OUTOFMEMORY) {
+                        return SoundIoErrorNoMem;
+                    } else {
+                        return SoundIoErrorOpeningDevice;
+                    }
+                }
+            } else if (hr == AUDCLNT_E_UNSUPPORTED_FORMAT) {
+                return SoundIoErrorIncompatibleDevice;
+            } else if (hr == E_OUTOFMEMORY) {
+                return SoundIoErrorNoMem;
+            } else {
+                return SoundIoErrorOpeningDevice;
             }
-        } else if (hr == AUDCLNT_E_UNSUPPORTED_FORMAT) {
-            return SoundIoErrorIncompatibleDevice;
-        } else if (hr == E_OUTOFMEMORY) {
-            return SoundIoErrorNoMem;
-        } else {
-            return SoundIoErrorOpeningDevice;
         }
     }
     REFERENCE_TIME max_latency_ref_time;
@@ -1623,6 +1735,9 @@ static int outstream_open_wasapi(struct SoundIoPrivate *si, struct SoundIoOutStr
 static int outstream_pause_wasapi(struct SoundIoPrivate *si, struct SoundIoOutStreamPrivate *os, bool pause) {
     struct SoundIoOutStreamWasapi *osw = &os->backend_data.wasapi;
 
+    if (SOUNDIO_ATOMIC_LOAD(osw->desired_pause_state) == pause)
+        return 0;
+
     SOUNDIO_ATOMIC_STORE(osw->desired_pause_state, pause);
     SOUNDIO_ATOMIC_FLAG_CLEAR(osw->pause_resume_flag);
     if (osw->h_event) {
@@ -2107,8 +2222,8 @@ static int instream_begin_read_wasapi(struct SoundIoPrivate *si, struct SoundIoI
         {
             return SoundIoErrorStreaming;
         }
-		isw->opened_buf_frames = frames_to_read;
-		isw->read_buf_frames_left = frames_to_read;
+        isw->opened_buf_frames = frames_to_read;
+        isw->read_buf_frames_left = frames_to_read;
 
         if (flags & AUDCLNT_BUFFERFLAGS_SILENT)
             isw->read_buf = NULL;
@@ -2122,7 +2237,7 @@ static int instream_begin_read_wasapi(struct SoundIoPrivate *si, struct SoundIoI
             isw->areas[ch].ptr = isw->read_buf + ch * instream->bytes_per_sample;
             isw->areas[ch].step = instream->bytes_per_frame;
 
-			isw->areas[ch].ptr += instream->bytes_per_frame * (isw->opened_buf_frames - isw->read_buf_frames_left);
+            isw->areas[ch].ptr += instream->bytes_per_frame * (isw->opened_buf_frames - isw->read_buf_frames_left);
         }
 
         *out_areas = isw->areas;
@@ -2137,13 +2252,13 @@ static int instream_end_read_wasapi(struct SoundIoPrivate *si, struct SoundIoInS
     struct SoundIoInStreamWasapi *isw = &is->backend_data.wasapi;
     HRESULT hr;
 
-	isw->read_buf_frames_left -= isw->read_frame_count;
+    isw->read_buf_frames_left -= isw->read_frame_count;
 
-	if (isw->read_buf_frames_left <= 0) {
-		if (FAILED(hr = IAudioCaptureClient_ReleaseBuffer(isw->audio_capture_client, isw->opened_buf_frames))) {
-			return SoundIoErrorStreaming;
-		}
-	}
+    if (isw->read_buf_frames_left <= 0) {
+        if (FAILED(hr = IAudioCaptureClient_ReleaseBuffer(isw->audio_capture_client, isw->opened_buf_frames))) {
+            return SoundIoErrorStreaming;
+        }
+    }
 
     return 0;
 }
